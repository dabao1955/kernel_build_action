name: 'Android Kernel Build Action'
description: "An action to build android kernel."
# Updated description for pull request demo

branding:
  icon: 'activity'
  color: 'blue'

inputs:
  kernel-url:
    description: 'URL of the Android kernel source repository'
    required: true
  kernel-branch:
    description: 'Branch name of the main kernel source repository'
    required: false
    default: main
  kernel-dir:
    description: 'Directory name for storing kernel source code'
    required: false
    default: kernel
  depth:
    description: 'Git clone depth for faster downloads'
    required: false
    default: '1'
  config:
    description: 'Name of the kernel configuration file to use'
    required: true
    default: defconfig
  arch:
    description: 'Target CPU architecture for cross-compilation'
    required: true
    default: arm64
  android-version:
    description: 'Android version for AOSP toolchain selection'
    required: false
    default: ''
  vendor:
    description: 'Enable vendor kernel source code integration'
    required: false
    default: 'false'
  vendor-url:
    description: 'URL of the vendor kernel source repository'
    required: false
  vendor-branch:
    description: 'Branch name of the vendor kernel source repository'
    required: false
    default: main
  vendor-dir:
    description: 'Directory name for storing vendor kernel source'
    required: false
    default: vendor
  aosp-clang:
    description: 'Use AOSP Clang toolchain'
    required: false
    default: 'false'
  aosp-clang-version:
    description: 'Version of AOSP Clang toolchain to use'
    required: false
    default: r383902
  aosp-gcc:
    description: 'Use AOSP GCC toolchain'
    required: false
    default: 'false'
  other-clang-url:
    description: 'URL of custom Clang toolchain'
    required: false
  other-clang-branch:
    description: 'Branch of the custom Clang toolchain'
    required: false
    default: main
  other-gcc64-url:
    description: 'URL of custom 64-bit GCC toolchain'
    required: false
  other-gcc64-branch:
    description: 'Branch of custom 64-bit GCC toolchain'
    required: false
    default: main
  other-gcc32-url:
    description: 'URL of custom 32-bit GCC toolchain'
    required: false
  other-gcc32-branch:
    description: 'Branch of custom 32-bit GCC toolchain'
    required: false
    default: main
  ksu:
    description: 'Enable KernelSU integration'
    required: false
    default: 'false'
  ksu-version:
    description: 'Version of KernelSU to integrate'
    required: false
    default: main
  ksu-lkm:
    description: 'Build KernelSU as a loadable kernel module'
    required: false
    default: 'false'
  ksu-other:
    description: 'Use a third-party KernelSU fork'
    required: false
    default: 'false'
  ksu-url:
    description: 'URL of the third-party KernelSU fork'
    required: false
  rekernel:
    description: 'Enable Re-Kernel support'
    required: false
    default: 'false'
  nethunter:
    description: 'Enable Kali NetHunter support'
    required: false
    default: 'false'
  nethunter-patch:
    description: 'Apply NetHunter-specific patches'
    required: false
    default: 'false'
  lxc:
    description: 'Enable LXC/Docker container support'
    required: false
    default: 'false'
  lxc-patch:
    description: 'Apply LXC-specific patches'
    required: false
    default: 'false'
  kvm:
    description: 'Enable KVM (Kernel Virtual Machine) support'
    required: false
    default: 'false'
  bbg:
    description: 'Enable BaseBandGuard support'
    required: false
    default: 'false'
  disable-lto:
    description: 'Disable Link Time Optimization (LTO)'
    required: false
    default: 'false'
  ccache:
    description: 'Enable ccache compilation cache'
    required: false
    default: 'false'
  anykernel3:
    description: 'Use AnyKernel3 packaging method'
    required: false
    default: 'false'
  anykernel3-url:
    description: 'URL of custom AnyKernel3 repository'
    required: false
  bootimg-url:
    description: 'URL to download the original boot.img file'
    required: false
  release:
    description: 'Automatically create a GitHub Release'
    required: false
    default: 'false'
  access-token:
    description: 'GitHub personal access token for releases'
    required: false
  extra-make-args:
    description: 'Additional make arguments in JSON array format'
    required: false
    default: '[]'

runs:
  using: 'composite'
  steps:

    - name: Setup ccache
      if: inputs.ccache == 'true'
      uses: hendrikmuhs/ccache-action@v1.2
      with:
        key: ${{ inputs.config }}-0cb68f9cbcbb3de9c966cf66ed51471fbe51419e
        max-size: 4G
        create-symlink: true

    - name: Build Kernel
      shell: bash
      run: |
        #!/bin/bash
        set -euo pipefail

        error() {
            echo "Error: $1" >&2
            exit 1
        }

        SU() {
            if [ "$(id -u)" -eq 0 ]; then
                "$@"
            else
                sudo "$@"
            fi
        }

        normalize_toolchain_dir() {
            local dir_path=$1
            local dir_name=$2

            if [ ! -d "$dir_path/bin" ]; then
                echo "Normalizing $dir_name directory structure..."
                for nested_dir in "$dir_path"/*/*; do
                    if [ -d "$nested_dir" ]; then
                        mv "$nested_dir"/* "$dir_path/" 2>/dev/null || true
                        break
                    fi
                done
            fi
        }

        download_and_extract() {
            local url=$1
            local output_name=$2
            local extract_dir=$3
            local branch=${4:-main}

            mkdir -p -v "$extract_dir"
            case "$url" in
                *.zip)
                    aria2c -o "${output_name}.zip" "$url"
                    unzip -q "${output_name}.zip" -d "$extract_dir"
                    ;;
                *.tar.*|*.gz|*.xz|*.bz2)
                    aria2c -o "${output_name}.${url##*.}" "$url"
                    tar -C "$extract_dir" -xf "${output_name}.${url##*.}"
                    ;;
                *)
                    git clone --depth="${{ inputs.depth }}" -b "$branch" "$url" "$extract_dir"
                    ;;
            esac
        }

        readonly DEFAULT_CLANG_VERSION="r383902"
        readonly DEFAULT_ANDROID_GCC_TAG="android-12.1.0_r27"
        readonly KERNEL_OUTPUT_DIR="out"
        readonly BUILD_ARTIFACT_DIR="build"

        if [[ ${GITHUB_ACTIONS} != "true" || ${OSTYPE} != "linux-gnu" || ( ! -f /bin/apt && ! -f /bin/pacman ) ]]; then
            error "This action requires GitHub Actions Linux runners (Debian-based or ArchLinux-based). Current: OSTYPE=${OSTYPE}, GITHUB_ACTIONS=${GITHUB_ACTIONS}"
        fi

        echo "::group::Installing dependency packages"
        if [ -f /bin/apt ]; then
            SU apt-get update
            SU apt-get install --no-install-recommends -y \
                binutils git make bc bison openssl curl zip kmod cpio flex libelf-dev \
                libssl-dev libtfm-dev libc6-dev device-tree-compiler ca-certificates \
                python3 xz-utils aria2 build-essential ccache pigz parallel jq opam libpcre3-dev
        else
            pacman -Syyu --no-confirm git base-devel opam aria2 python3 aria2
        fi
        echo "::endgroup::"

        if [ "${{ inputs.aosp-clang }}" == "true" ]; then
            echo "::group::Downloading AOSP Clang"
            if [ "${{ inputs.aosp-gcc }}" != "true" ]; then
                error "AOSP GCC is required when using AOSP Clang."
            fi
            AOSP_CLANG_URL="https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/+archive/refs/heads/"
            if [ -n "${{ inputs.android-version }}" ]; then
                AOSP_CLANG_URL+="android${{ inputs.android-version }}-release/clang-${{ inputs.aosp-clang-version }}.tar.gz"
            else
                AOSP_CLANG_URL+="mirror-goog-main-llvm-toolchain-source/clang-${{ inputs.aosp-clang-version }}.tar.gz"
            fi
            download_and_extract "$AOSP_CLANG_URL" "aosp-clang" "$HOME/clang"
            echo "::endgroup::"
        elif [ -n "${{ inputs.other-clang-url }}" ]; then
            echo "::group::Downloading Third-party Clang"
            download_and_extract "${{ inputs.other-clang-url }}" "clang" "$HOME/clang" "${{ inputs.other-clang-branch }}"
            normalize_toolchain_dir "$HOME/clang" "Clang"
            if ! ls "$HOME/clang"/*-linux-* &>/dev/null; then
                echo "Binutils not found in clang directory. Downloading AOSP GCC"
                export NEED_GCC=1
            fi
            echo "::endgroup::"
        else
            SU apt-get install -y clang lld binutils-aarch64-linux-gnu binutils-arm-linux-gnueabihf
        fi

        if [ "${{ inputs.aosp-gcc }}" == "true" ] || [ -n "${NEED_GCC:-}" ]; then
            echo "::group::Downloading AOSP GCC"
            if [ -n "${{ inputs.android-version }}" ]; then
                AOSP_GCC64_URL="https://android.googlesource.com/platform/prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9"
                AOSP_GCC32_URL="https://android.googlesource.com/platform/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9"
                AOSP_GCC_BRANCH="android${{ inputs.android-version }}-release"
            else
                AOSP_GCC64_URL="https://android.googlesource.com/platform/prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/+archive/refs/tags/android-12.1.0_r27.tar.gz"
                AOSP_GCC32_URL="https://android.googlesource.com/platform/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/+archive/refs/tags/android-12.1.0_r27.tar.gz"
            fi
            download_and_extract "$AOSP_GCC64_URL" "gcc-aarch64" "$HOME/gcc-64" "${AOSP_GCC_BRANCH:-main}"
            download_and_extract "$AOSP_GCC32_URL" "gcc-arm" "$HOME/gcc-32" "${AOSP_GCC_BRANCH:-main}"
            echo "::endgroup::"
        elif [ -n "${{ inputs.other-gcc64-url }}" ] || [ -n "${{ inputs.other-gcc32-url }}" ]; then
            echo "::group::Downloading Third-party GCC"
            if [ -n "${{ inputs.other-gcc64-url }}" ]; then
                download_and_extract "${{ inputs.other-gcc64-url }}" "gcc-aarch64" "$HOME/gcc-64" "${{ inputs.other-gcc64-branch }}"
            fi
            if [ -n "${{ inputs.other-gcc32-url }}" ]; then
                download_and_extract "${{ inputs.other-gcc32-url }}" "gcc-arm" "$HOME/gcc-32" "${{ inputs.other-gcc32-branch }}"
            fi
            echo "::endgroup::"
        fi

        normalize_toolchain_dir "$HOME/gcc-64" "GCC64"
        normalize_toolchain_dir "$HOME/gcc-32" "GCC32"

        echo "::group::Pulling Kernel Source"
        git clone --recursive -b "${{ inputs.kernel-branch }}" --depth="${{ inputs.depth }}" "${{ inputs.kernel-url }}" "kernel/${{ inputs.kernel-dir }}"
        echo "::endgroup::"

        if [ "${{ inputs.vendor }}" == "true" ]; then
            echo "::group::Pulling Kernel Vendor Source"
            git clone -b "${{ inputs.vendor-branch }}" --depth="${{ inputs.depth }}" "${{ inputs.vendor-url }}" "kernel/${{ inputs.vendor-dir }}"
            if [ -d "kernel/${{ inputs.vendor-dir }}/vendor" ]; then
                cp -rv "kernel/${{ inputs.vendor-dir }}/vendor" kernel
                cp -rv "kernel/${{ inputs.vendor-dir }}/vendor" ./
            fi
            echo "::endgroup::"
        fi

        cd "kernel/${{ inputs.kernel-dir }}"

        if [ -d "$HOME/gcc-64/bin" ] || [ -d "$HOME/gcc-32/bin" ]; then
            for GCC_DIR in "$HOME/gcc-64" "$HOME/gcc-32"; do
                find "$GCC_DIR"/*/*/bin -type d -exec sh -c 'mv "$(dirname "$1")"/* "$2"/' _ {} "$GCC_DIR" \; -quit >/dev/null 2>&1 || true
                if [ -d "$GCC_DIR/bin" ]; then
                    for FILE in "$GCC_DIR/bin"/*; do
                        [ ! -e "$FILE" ] && continue
                        FILE_NAME=$(basename "$FILE")
                        MATCHED_DIR=""
                        while IFS= read -r FOLDER; do
                            FOLDER_NAME=$(basename "$FOLDER")
                            if [[ "$FILE_NAME" == "$FOLDER_NAME"* ]]; then
                                MATCHED_DIR="$FOLDER_NAME"
                                break
                            fi
                        done < <(find "$GCC_DIR" -mindepth 1 -maxdepth 1 -type d | sort -r)
                        if [ -n "$MATCHED_DIR" ]; then
                            case "$GCC_DIR" in
                                "$HOME/gcc-64") GCC64="$MATCHED_DIR" ;;
                                "$HOME/gcc-32") GCC32="$MATCHED_DIR" ;;
                            esac
                            break
                        fi
                    done
                fi
            done
        fi

        VERSION=$(grep -E '^VERSION = ' Makefile | awk '{print $3}')
        PATCHLEVEL=$(grep -E '^PATCHLEVEL = ' Makefile | awk '{print $3}')
        SUBLEVEL=$(grep -E '^SUBLEVEL = ' Makefile | awk '{print $3}')

        if [ "$VERSION" -lt 5 ] 2>/dev/null || { [ "$VERSION" -eq 5 ] 2>/dev/null && [ "$PATCHLEVEL" -lt 10 ] 2>/dev/null; }; then
            NONGKI=true
        fi

        CONFIG_FILE="arch/${{ inputs.arch }}/configs/${{ inputs.config }}"
        if [ "${{ inputs.ksu }}" == "true" ]; then
            echo "::group::Initializing KernelSU"
            if [ -f KernelSU/kernel/Kconfig ]; then
                echo "KernelSU has been initialized, skipping."
            else
                if [ "${{ inputs.ksu-other }}" == "true" ]; then
                    if [ -z "${{ inputs.ksu-url }}" ]; then
                        error "ksu-url input is required when ksu-other is set to true"
                    fi
                    curl -sSLf "${{ inputs.ksu-url }}/raw/${{ inputs.ksu-version }}/kernel/setup.sh" -o ksu_setup.sh || error "Failed to download KernelSU setup script from ${ksu_url}"
                else
                    curl -sSLf "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" -o ksu_setup.sh || error "Failed to download KernelSU setup script from official repository"
                fi

                echo "Kernel version: $VERSION.$PATCHLEVEL.$SUBLEVEL"
                KVER="${{ inputs.ksu-version }}"
                if [ "$NONGKI" == "true" ] && [ "${{ inputs.ksu-other }}" == "false" ]; then
                    echo "Warning: The KernelSU version you selected was detected to be ${{ inputs.ksu-version }}, but KernelSU has dropped support for the non-gki kernel since 0.9.5."
                    echo "This will force switch to v0.9.5."
                    KVER=v0.9.5
                fi

                bash ksu_setup.sh "$KVER" || error "Failed to execute KernelSU setup script"
            fi

            if [ "${{ inputs.ksu-lkm }}" == "true" ]; then
                if grep -q "CONFIG_KPROBES=y" "$CONFIG_FILE"; then
                    sed -i 's/CONFIG_KSU=y/CONFIG_KSU=m/g' "$CONFIG_FILE"
                else
                    sed -i '/config KSU/,/help/{s/default y/default m/}' drivers/kernelsu/Kconfig
                fi
            elif [ "$NONGKI" == "true" ]; then
                if grep -q "CONFIG_KPROBES=y" "$CONFIG_FILE" 2>/dev/null; then
                    echo "CONFIG_KPROBES is enabled, skip patch."
                else
                    opam init --disable-sandboxing --yes
                    eval $(opam env)
                    opam install --yes coccinelle
                    if curl -sSLf "https://github.com/dabao1955/kernel_build_action/raw/main/kernelsu/apply_cocci.sh" -o /tmp/apply_cocci.sh; then
                        bash /tmp/apply_cocci.sh || echo "Warning: Failed to apply KernelSU patches"
                        rm -f /tmp/apply_cocci.sh
                    else
                        echo "Warning: Failed to download apply_cocci.sh"
                    fi
                fi
            fi
            echo "::endgroup::"
        fi

        if [ "${{ inputs.bbg }}" == "true" ]; then
            echo "::group::Initializing BBG"
            curl -Ss https://github.com/vc-teahouse/Baseband-guard/raw/main/setup.sh | bash
            sed -i '/^config LSM$/,/^help$/{ /^[[:space:]]*default/ { /baseband_guard/! s/lockdown/lockdown,baseband_guard/ } }' security/Kconfig
            echo "CONFIG_BBG=y" >> "$CONFIG_FILE"
            echo "::endgroup::"
        fi

        if [ "${{ inputs.rekernel }}" == "true" ]; then
            echo "::group::Initializing Re-Kernel"
            curl -sSLf https://github.com/dabao1955/kernel_build_action/raw/main/rekernel/patch.sh | bash || error "Failed to download or execute Re-Kernel patch script"
            echo "::endgroup::"
        fi

        if [ -f scripts/dtc/libfdt/mkdtboimg.py ]; then
            if grep -q python2 scripts/Makefile.lib 2>/dev/null; then
                echo "::group::Using mkdtboimg Python3 version instead of Python2 version"
                rm -f scripts/dtc/libfdt/mkdtboimg.py
                cp -v "${{ github.action_path }}/mkdtboimg.py" scripts/dtc/libfdt/mkdtboimg.py
                echo "::endgroup::"
            elif grep -q scripts/ufdt scripts/Makefile.lib 2>/dev/null && [ ! -d scripts/ufdt ]; then
                mkdir -p ufdt/libufdt/utils/src
                cp -v "${{ github.action_path }}/mkdtboimg.py" ufdt/libufdt/utils/src/mkdtboimg.py
            fi
            if [ ! -f /usr/bin/python2 ]; then
                SU ln -sf /usr/bin/python3 /usr/bin/python2
            fi
        else
            echo "::group::Downloading mkdtboimg to /usr/local/bin"
            SU cp -v "${{ github.action_path }}/mkdtboimg.py" /usr/local/bin/mkdtboimg
            SU chmod +x /usr/local/bin/mkdtboimg
            echo "::endgroup::"
        fi

        if [ "${{ inputs.nethunter }}" == "true" ]; then
            echo "::group::Initializing Kali NetHunter"
            cp -v "${{ github.action_path }}/nethunter/config.sh" nconfig.sh
            bash nconfig.sh "$CONFIG_FILE" -w
            if [ "${{ inputs.nethunter-patch }}" == "true" ]; then
                git apply "${{ github.action_path }}/nethunter/add-wifi-injection.patch"
                git apply "${{ github.action_path }}/nethunter/fix-ath9k-naming-conflict.patch"
                if [ "$PATCHLEVEL" -lt 19 ]; then
                    git apply "${{ github.action_path }}/nethunter/add-wifi-injection-4.14.patch"
                fi
            fi
            echo "::endgroup::"
        fi

        if [ "${{ inputs.disable-lto }}" == "true" ]; then
            if grep -q "LTO" "$CONFIG_FILE"; then
                sed -i 's/CONFIG_LTO=y/CONFIG_LTO=n/' "$CONFIG_FILE"
                sed -i 's/CONFIG_LTO_CLANG=y/CONFIG_LTO_CLANG=n/' "$CONFIG_FILE"
                sed -i 's/CONFIG_THINLTO=y/CONFIG_THINLTO=n/' "$CONFIG_FILE"
                echo "CONFIG_LTO_NONE=y" >> "$CONFIG_FILE"
            fi
        fi

        if [ "${{ inputs.kvm }}" == "true" ]; then
            echo "CONFIG_VIRTUALIZATION=y" >> "$CONFIG_FILE"
            echo "CONFIG_KVM=y" >> "$CONFIG_FILE"
            echo "CONFIG_KVM_MMIO=y" >> "$CONFIG_FILE"
            echo "CONFIG_KVM_ARM_HOST=y" >> "$CONFIG_FILE"
        fi

        if [ "${{ inputs.lxc }}" == "true" ]; then
            echo "::group::Enabling LXC"
            cp -v "${{ github.action_path }}/lxc/config.sh" config.sh
            bash config.sh "$CONFIG_FILE" -w
            if [ "${{ inputs.lxc-patch }}" == "true" ]; then
                curl -sSL "${{ github.action_path }}/lxc/patch.sh" | bash
            fi
            echo "::endgroup::"
        fi

        echo "::group:: Building Kernel with selected cross compiler"

        if [[ "${{ inputs.extra-make-args }}" != "[]" ]]; then
            readarray -t EXTRA_ARGS < <(jq -r '.[]' <<< "${{ inputs.extra-make-args }}")
        else
            EXTRA_ARGS=()
        fi

        SAFE_EXTRA_ARGS=()
        for arg in "${EXTRA_ARGS[@]}"; do
            case "$arg" in
                CC=*|CXX=*|LD=*|AS=*|AR=*|NM=*|STRIP=*|OBJCOPY=*|OBJDUMP=*|\
                HOSTCC=*|KBUILD_HOSTCC=*|SHELL=*|MAKEFLAGS=*|MAKE=*|\
                CROSS_COMPILE=*|CLANG_TRIPLE=*|LLVM=*|CLVM=*|O=*|ARCH=*)
                    echo "::warning::Ignoring override of critical variable: $arg"
                    ;;
                *)
                    SAFE_EXTRA_ARGS+=("$arg")
                    ;;
            esac
        done

        mkdir -p -v "${KERNEL_OUTPUT_DIR}"

        if [[ -d "$HOME/clang/bin" ]]; then
            CMD_PATH="$HOME/clang/bin"
            CMD_CC="clang"
            if [[ -d "$HOME/gcc-64/bin" ]] || [[ -d "$HOME/gcc-32/bin" ]]; then
                CMD_CROSS_COMPILE="$HOME/gcc-64/bin/${GCC64}-"
                CMD_CROSS_COMPILE_ARM32="$HOME/gcc-32/bin/${GCC32}-"
            fi
        elif [[ -d "$HOME/gcc-64/bin" ]] || [[ -d "$HOME/gcc-32/bin" ]]; then
            CMD_PATH="$HOME/gcc-64/bin:$HOME/gcc-32/bin"
            if [[ -n "${GCC64:-}" ]]; then
                CMD_CC="$HOME/gcc-64/bin/${GCC64}-gcc"
                CMD_CROSS_COMPILE="${GCC64}-"
            else
                CMD_CC="$HOME/gcc-32/bin/${GCC32}-gcc"
                CMD_CROSS_COMPILE="${GCC32}-"
            fi
            CMD_CROSS_COMPILE_ARM32="${GCC32}-"
        else
            CMD_CC="/usr/bin/clang"
            CMD_CROSS_COMPILE="/usr/bin/aarch64-linux-gnu-"
            CMD_CROSS_COMPILE_ARM32="arm-linux-gnueabihf-"
        fi

        if [[ "${{ inputs.ccache }}" == "true" ]]; then
            export USE_CCACHE=1
            export PATH="/usr/lib/ccache:/usr/local/opt/ccache/libexec:$PATH"
            CMD_PATH="/usr/lib/ccache:$CMD_PATH"
        fi

        make_args=(
            -j"$(nproc --all)"
            "${{ inputs.config }}"
            "ARCH=${{ inputs.arch }}"
            "O=out"
            all
            "${SAFE_EXTRA_ARGS[@]}"
        )

        if [[ "${{ inputs.arch }}" == "arm" ]]; then
            CMD_CLANG_TRIPLE="${CMD_CROSS_COMPILE_ARM32}"
        else
            CMD_CLANG_TRIPLE="aarch64-linux-gnu-"
        fi

        export PATH="$CMD_PATH:$PATH"
        make \
            CC="$CMD_CC" \
            CROSS_COMPILE="$CMD_CROSS_COMPILE" \
            CROSS_COMPILE_ARM32="$CMD_CROSS_COMPILE_ARM32" \
            CLANG_TRIPLE="$CMD_CLANG_TRIPLE" \
           "${make_args[@]}"

        echo "::endgroup::"

        unset CMD_PATH CMD_CC CMD_CLANG_TRIPLE CMD_CROSS_COMPILE CMD_CROSS_COMPILE_ARM32 USE_CCACHE CLANG_PATH HOMES KVER SWAP_FILE SUBLEVEL PATCHLEVEL VERSION GCC_DIR FILE FILE_NAME MATCHED_DIR FOLDER FOLDER_NAME GCC64 GCC32 NEED_GCC AOSP_CLANG_URL OTHER_CLANG_URL AOSP_GCC64_URL AOSP_GCC32_URL AOSP_GCC_BRANCH OTHER_GCC64_URL OTHER_GCC32_URL EXTRA_ARGS make_args SAFE_EXTRA_ARGS EXTRA_CMD

        if [ "${{ inputs.anykernel3 }}" == "false" ]; then
            echo "::group::Packaging boot.img"

            if [ -z "${{ inputs.bootimg-url }}" ]; then
                error "bootimg-url input is required when anykernel3 is set to false"
            fi

            mkdir split
            cd split
            HOST_ARCH=$(dpkg --print-architecture)
            case "${HOST_ARCH}" in
                armv7*|armv8l|arm64|armhf|arm) aria2c https://github.com/Shubhamvis98/AIK/raw/4ac321dfd48e16344e6146c505708aa720ff0bb3/bin/magiskboot_arm -o magiskboot && chmod +x magiskboot ;;
                i*86|x86|amd64|x86_64) aria2c https://github.com/Shubhamvis98/AIK/raw/4ac321dfd48e16344e6146c505708aa720ff0bb3/bin/magiskboot_x86 -o magiskboot && chmod +x magiskboot ;;
                *) error "Unknown CPU architecture for this device!" ;;
            esac
            unset HOST_ARCH
            aria2c "${{ inputs.bootimg-url }}" -o boot.img || error "Failed to download boot.img"
            ./magiskboot unpack boot.img > nohup.out 2>&1 # nohup is not working in github ci!
            export FMT=$(cat nohup.out | grep "KERNEL_FMT" | awk '{gsub("\\[", "", $2); gsub("\\]", "", $2); print $2}')
            rm -rf kernel

            find_kernel_image() {
                local pattern=$1
                local description=$2
                mapfile -t images < <(find ../out/arch/${{ inputs.arch }}/boot -name "$pattern" ! -name "*-*" 2>/dev/null)

                if [ ${#images[@]} -eq 0 ]; then
                    error "Failed to find $description"
                elif [ ${#images[@]} -gt 1 ]; then
                    error "Multiple $description found: ${images[*]}"
                fi

                cp -v "${images[0]}" kernel
            }

            if [ "$FMT" == "raw" ]; then
                find_kernel_image "Image" "raw kernel Image"
            else
                if [ -f dtb ]; then
                    find_kernel_image "Image.*-dtb" "kernel Image with dtb"
                else
                    find_kernel_image "Image.*" "compressed kernel Image"
                fi
            fi
            ./magiskboot repack boot.img
            rm -f boot.img
            mkdir -p ../../../${BUILD_ARTIFACT_DIR}
            find . -name "*.img" -exec mv -v {} ../../../${BUILD_ARTIFACT_DIR}/boot.img \;
            cd ..
            echo "::endgroup::"
        else
            echo "::group:: Packaging Anykernel3 flasher"
            if [ -n "${{ inputs.anykernel3-url }}" ]; then
                git clone "${{ inputs.anykernel3-url }}" AnyKernel3
            else
                git clone https://github.com/osm0sis/AnyKernel3
                sed -i 's!BLOCK=/dev/block/platform/omap/omap_hsmmc.0/by-name/boot;!BLOCK=auto;!g' AnyKernel3/anykernel.sh
                sed -i 's/do.devicecheck=1/do.devicecheck=0/g' AnyKernel3/anykernel.sh
                sed -i 's/IS_SLOT_DEVICE=0;/IS_SLOT_DEVICE=auto;/g' AnyKernel3/anykernel.sh
            fi

            copy_kernel_image() {
                local pattern=$1
                local description=$2
                mapfile -t images < <(find out/arch/${{ inputs.arch }}/boot -name "$pattern" ! -name "*-*" 2>/dev/null)

                if [ ${#images[@]} -eq 0 ]; then
                    return 1
                elif [ ${#images[@]} -gt 1 ]; then
                    error "Multiple $description found: ${images[*]}"
                fi

                cp -rv "${images[0]}" AnyKernel3/
                return 0
            }

            if ! copy_kernel_image "Image.*-dtb" "kernel Image with dtb"; then
                if ! copy_kernel_image "Image.*" "compressed kernel Image"; then
                    if [ ! -f out/arch/${{ inputs.arch }}/boot/Image ]; then
                        error "Kernel Image not found in out/arch/${{ inputs.arch }}/boot/"
                    fi
                    cp out/arch/${{ inputs.arch }}/boot/Image AnyKernel3/ -rv
                fi
            fi

            if [ -f out/arch/${{ inputs.arch }}/boot/dtbo.img ]; then
                cp out/arch/${{ inputs.arch }}/boot/dtbo.img AnyKernel3/ -rv
            else
                echo "Failed to copy DTBO image. File not found."
            fi

            if [ -f out/arch/${{ inputs.arch }}/boot/dtb.img ]; then
                cp out/arch/${{ inputs.arch }}/boot/dtb.img AnyKernel3/ -rv
            elif [ -f out/arch/${{ inputs.arch }}/boot/dtb ]; then
                cp out/arch/${{ inputs.arch }}/boot/dtb AnyKernel3/ -rv
            else
                echo "Failed to copy dtb. File not found."
            fi

            rm -rf -v AnyKernel3/.git* AnyKernel3/README.md
            mkdir -p -v ../../${BUILD_ARTIFACT_DIR}
            if [ "${{ inputs.release }}" = "false" ]; then
                cp -r -v AnyKernel3/* ../../${BUILD_ARTIFACT_DIR}
            else
                cd AnyKernel3 && zip -r Anykernel3-flasher.zip ./* && mv -v Anykernel3-flasher.zip .. && cd .. && mv -v Anykernel3-flasher.zip ../../${BUILD_ARTIFACT_DIR}/
            fi
            echo "::endgroup::"
        fi

    - id: uploadi
      if: ${{ inputs.release == 'false' && inputs.anykernel3 == 'false' }}
      uses: actions/upload-artifact@v6
      with:
        name: kernel-built-bootimg
        path: build/*
        if-no-files-found: error
        overwrite: true

    - id: uploada
      if: ${{ inputs.release == 'false' && inputs.anykernel3 == 'true' }}
      uses: actions/upload-artifact@v6
      with:
        name: Anykernel3-flasher
        path: build/*
        if-no-files-found: error
        overwrite: true

    - id: release
      if: inputs.release == 'true'
      uses: softprops/action-gh-release@v2
      env:
        GITHUB_TOKEN: ${{ inputs.access-token }}
      with:
        name: Last CI build kernel
        tag_name: last-ci-${{ github.sha }}
        files: build/*
        make_latest: true
        body: |
          Build Information:
          - Config: ${{ inputs.config }}
          - Branch: ${{ inputs.kernel-branch }}
          - Source: ${{ inputs.kernel-url }}
          - Architecture: ${{ inputs.arch }}

          Features:
          - KernelSU: ${{ inputs.ksu }}
          - NetHunter: ${{ inputs.nethunter }}
          - LXC: ${{ inputs.lxc }}
          - KVM: ${{ inputs.kvm }}
          - Rekernel: ${{ inputs.rekernel }}

          Build Details:
          - Timestamp: ${{ github.event.repository.updated_at }}
          - Workflow: ${{ github.workflow }}
          - Run ID: ${{ github.run_id }}
          - Commit: ${{ github.sha }}
